<!DOCTYPE html>
<html lang="it">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Mappa Immagini Navigabile - Disposizione Casual</title>
  <style>
    html, body {
      margin: 0;
      padding: 0;
      height: 100%;
      overflow: hidden;
      background: #222;
      user-select: none;
      touch-action: none;
    }
    /* L’area di visualizzazione intera */
    #viewport {
      width: 100%;
      height: 100%;
      position: relative;
      cursor: grab;
      overflow: hidden;
    }
    /* Il container che contiene le immagini. Lo posizioneremo e scaleremo via JS */
    #grid {
      position: absolute;
      top: 0;
      left: 0;
      will-change: transform;
    }
    /* Le immagini vengono visualizzate con le loro dimensioni reali, senza cropping */
    .image {
      display: block;
      /* Rimuovo object-fit per rispettare le proporzioni naturali */
      /* Per farle “attaccare” fra loro, la disposizione di base verrà calcolata via JS */
      margin: 0;
      padding: 0;
    }
  </style>
</head>
<body>
  <div id="viewport">
    <div id="grid"></div>
  </div>

  <script>
    /* 
      Lista delle immagini. Qui le ripeto più volte per simulare un gran numero 
      – per vedere come si comporta la mappa.
    */
    const imageFilenames = [
      "imgs/Unknown-1.jpeg",
      "imgs/Unknown.jpeg",
      "imgs/images-1.jpeg",
      "imgs/images.jpeg",
      "imgs/image5.jpg"
    ];
    const images = [];
    // Genero una collezione di immagini ripetuta: ad es. 100 immagini
    for(let i = 0; i < 100; i++){
      images.push( imageFilenames[i % imageFilenames.length] );
    }

    const grid = document.getElementById("grid");
    // Per questo esempio assumiamo immagini di base con larghezza reale pari a 500px.
    // Se le immagini reali hanno dimensioni differenti, bisognerà leggerne le dimensioni al caricamento.
    const baseWidth = 500; 
    const baseHeight = 500; 

    /* 
      Creiamo una “disposizione casuale” partendo da una griglia di base:
      - Le immagini vengono posizionate una accanto all’altra, senza spazi.
      - Ogni immagine conserva la sua posizione di griglia, ma a ciascuna
        applichiamo una leggera rotazione casuale (da -3° a +3°) per dare un aspetto meno "rigido".
    */
    // Calcolo di quanti elementi per riga: qui scelgo 10 per esempio
    const cols = 10;
    const rows = Math.ceil(images.length / cols);

    // Salvo le posizioni minime per centrare l'intera griglia in seguito
    let gridWidth = cols * baseWidth;
    let gridHeight = rows * baseHeight;

    images.forEach((src, index) => {
      const img = document.createElement("img");
      img.src = src;
      img.className = "image";

      // Calcola la posizione sulla griglia
      let col = index % cols;
      let row = Math.floor(index / cols);
      let xPos = col * baseWidth;
      let yPos = row * baseHeight;

      img.style.position = "absolute";
      img.style.left = xPos + "px";
      img.style.top = yPos + "px";

      // Applica una piccola rotazione casuale: per effetto casuale ma non eccessivo
      let rot = (Math.random() * 6 - 3).toFixed(2); // tra -3 e 3 gradi
      img.style.transform = `rotate(${rot}deg)`;

      grid.appendChild(img);
    });

    // Variabili per gestione della trasformazione
    let zoomLevel = 1.4;  // partiamo già con un po' di zoom
    let translation = { x: 0, y: 0 };
    let isDragging = false;
    let dragStart = { x: 0, y: 0 };

    // Funzione per aggiornare la trasformazione del container
    function updateTransform() {
      grid.style.transform = `translate(${translation.x}px, ${translation.y}px) scale(${zoomLevel})`;
    }

    // Funzione per centrare la griglia nel viewport al caricamento e al resize
    function centerGrid() {
      const viewportWidth = window.innerWidth;
      const viewportHeight = window.innerHeight;
      // Centriamo la griglia in base alla sua dimensione in scala corrente
      translation.x = (viewportWidth - gridWidth * zoomLevel) / 2;
      translation.y = (viewportHeight - gridHeight * zoomLevel) / 2;
      updateTransform();
    }

    centerGrid();
    window.addEventListener("resize", centerGrid);

    // Funzione zoom: mantiene il punto sotto il cursore fisso
    function zoom(event) {
      event.preventDefault();
      
      // Posizione del puntatore (mouse o touch) rispetto alla viewport
      const pointer = { x: event.clientX, y: event.clientY };
      // Calcola il nuovo livello di zoom
      const factor = event.deltaY < 0 ? 1.1 : 0.9;
      const newZoom = Math.min(Math.max(zoomLevel * factor, 0.5), 5);
      // Applica la formula: newTranslation = pointer - ((pointer - oldTranslation) * newZoom/oldZoom)
      translation.x = pointer.x - ( (pointer.x - translation.x) * newZoom/zoomLevel );
      translation.y = pointer.y - ( (pointer.y - translation.y) * newZoom/zoomLevel );
      
      zoomLevel = newZoom;
      updateTransform();
    }
    document.getElementById("viewport").addEventListener("wheel", zoom);

    // Gestione del drag (mouse)
    function startDrag(e) {
      isDragging = true;
      dragStart.x = e.clientX;
      dragStart.y = e.clientY;
      document.body.style.cursor = "grabbing";
    }
    function onDrag(e) {
      if (!isDragging) return;
      const dx = e.clientX - dragStart.x;
      const dy = e.clientY - dragStart.y;
      translation.x += dx;
      translation.y += dy;
      dragStart.x = e.clientX;
      dragStart.y = e.clientY;
      updateTransform();
    }
    function endDrag() {
      isDragging = false;
      document.body.style.cursor = "grab";
      // Al termine del drag, se non riusciamo il wrapping in stile pacman,
      // ritorniamo sempre al centro iniziale
      centerGrid();
    }
    document.addEventListener("mousedown", startDrag);
    document.addEventListener("mousemove", onDrag);
    document.addEventListener("mouseup", endDrag);

    // Supporto per dispositivi touch (mobile)
    let touchStart = { x: 0, y: 0 };
    document.addEventListener("touchstart", function(e) {
      if(e.touches.length === 1) {
        isDragging = true;
        touchStart.x = e.touches[0].clientX;
        touchStart.y = e.touches[0].clientY;
      }
    }, {passive: false});
    document.addEventListener("touchmove", function(e) {
      if (!isDragging || e.touches.length !== 1) return;
      const touch = e.touches[0];
      let dx = touch.clientX - touchStart.x;
      let dy = touch.clientY - touchStart.y;
      translation.x += dx;
      translation.y += dy;
      touchStart.x = touch.clientX;
      touchStart.y = touch.clientY;
      updateTransform();
    }, {passive: false});
    document.addEventListener("touchend", function(e) {
      isDragging = false;
      centerGrid();
    });
  </script>
</body>
</html>
