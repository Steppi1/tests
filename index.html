<!DOCTYPE html>
<html lang="it">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Mosaic Navigabile</title>
  <style>
    /* Schermo intero senza scroll */
    html, body {
      margin: 0;
      padding: 0;
      height: 100%;
      overflow: hidden;
      background: #222;
      user-select: none;
      touch-action: none;
    }
    /* Viewport intero per l'interazione */
    #viewport {
      width: 100%;
      height: 100%;
      position: relative;
      overflow: hidden;
      cursor: grab;
    }
    /* Container del mosaic: qui verranno posizionate le immagini in modo assoluto */
    #grid {
      position: absolute;
      top: 0;
      left: 0;
      will-change: transform;
    }
    /* Le immagini vengono caricate “naturali” senza forzature: nessun cropping e nessuna rotazione */
    #grid img {
      position: absolute;
      margin: 0;
      padding: 0;
      /* Non impostiamo width/height: l'immagine userà le sue dimensioni naturali */
    }
  </style>
</head>
<body>
  <div id="viewport">
    <div id="grid"></div>
  </div>

  <script>
    /**************************************************
     * CONFIGURAZIONE DEL MOSAIC
     **************************************************/
    // Lista dei percorsi delle immagini (rispetta la struttura della cartella "imgs")
    const imageFilenames = [
      "imgs/Unknown-1.jpeg",
      "imgs/Unknown.jpeg",
      "imgs/images-1.jpeg",
      "imgs/images.jpeg",
      "imgs/image5.jpg"
    ];
    // Per simulare un mosaic denso, ripetiamo la lista più volte
    const repeatFactor = 20; // il numero totale di immagini sarà imageFilenames.length * repeatFactor
    const imagesList = [];
    for (let i = 0; i < repeatFactor; i++) {
      imageFilenames.forEach(filename => imagesList.push(filename));
    }
    
    // Per questo esempio supponiamo – come per le dummy – che tutte le immagini abbiano dimensioni uniformi
    // Se usi immagini reali di diversa grandezza, conviene calcolare al momento del load le dimensioni naturali.
    const baseWidth  = 500;  // dimensione naturale orizzontale (modifica se necessario)
    const baseHeight = 500;  // dimensione naturale verticale (modifica se necessario)
    
    // Impostiamo la disposizione in “griglia puzzle”: scegliamo un numero di colonne fisse.
    const cols = 10;
    const rows = Math.ceil(imagesList.length / cols);
    
    // Calcoliamo l'area complessiva del mosaic (non scalata)
    const mosaicWidth  = cols * baseWidth;
    const mosaicHeight = rows * baseHeight;
    
    const grid = document.getElementById("grid");
    // Impostiamo le dimensioni del container (utile per il calcolo degli spostamenti)
    grid.style.width  = mosaicWidth + "px";
    grid.style.height = mosaicHeight + "px";
    
    // Posizioniamo ogni immagine in modo che il bordo destro di una tocchi esattamente il bordo sinistro della successiva
    imagesList.forEach((src, index) => {
      const img = document.createElement("img");
      img.src = src;
      // Il caricamento automatico mostrerà l'immagine nelle sue dimensioni naturali;
      // per il layout, usiamo dimensioni note (baseWidth e baseHeight) – se le immagini reali hanno altre dimensioni, andrebbe modificato questo calcolo.
      const col = index % cols;
      const row = Math.floor(index / cols);
      img.style.left = (col * baseWidth) + "px";
      img.style.top  = (row * baseHeight) + "px";
      grid.appendChild(img);
    });
    
    /**************************************************
     * GESTIONE DI ZOOM E PAN
     **************************************************/
    const viewport = document.getElementById("viewport");
    
    // Stato interattivo: zoom e traslazione attuali
    let zoomLevel = 1.4; // zoom iniziale (modifica a piacere)
    let translation = { x: 0, y: 0 };
    
    // Applica la trasformazione al container grid
    function updateTransform() {
      grid.style.transform = `translate(${translation.x}px, ${translation.y}px) scale(${zoomLevel})`;
    }
    
    // Funzione per centrare il mosaic nel viewport
    function centerGrid() {
      const vpWidth  = viewport.clientWidth;
      const vpHeight = viewport.clientHeight;
      const currentWidth  = mosaicWidth  * zoomLevel;
      const currentHeight = mosaicHeight * zoomLevel;
      translation.x = (vpWidth  - currentWidth)  / 2;
      translation.y = (vpHeight - currentHeight) / 2;
      updateTransform();
    }
    
    // Al caricamento e al resize, il mosaic viene centrato
    centerGrid();
    window.addEventListener("resize", centerGrid);
    
    /**************************************************
     * PAN (drag con mouse e touch)
     **************************************************/
    let isDragging = false;
    let dragStart = { x: 0, y: 0 };
    let startTranslation = { x: 0, y: 0 };
    
    function onDragStart(clientX, clientY) {
      isDragging = true;
      dragStart = { x: clientX, y: clientY };
      startTranslation = { ...translation };
      viewport.style.cursor = "grabbing";
      // Durante il drag non usiamo transizioni
      grid.style.transition = "none";
    }
    
    function onDragMove(clientX, clientY) {
      if (!isDragging) return;
      const dx = clientX - dragStart.x;
      const dy = clientY - dragStart.y;
      translation.x = startTranslation.x + dx;
      translation.y = startTranslation.y + dy;
      updateTransform();
    }
    
    function onDragEnd() {
      if (!isDragging) return;
      isDragging = false;
      viewport.style.cursor = "grab";
      // Solo se il mosaic è completamente fuori dal viewport (tutto spazio nero) lo riportiamo al centro.
      const vpWidth  = viewport.clientWidth;
      const vpHeight = viewport.clientHeight;
      const gridRect = {
        left: translation.x,
        top: translation.y,
        right: translation.x + mosaicWidth * zoomLevel,
        bottom: translation.y + mosaicHeight * zoomLevel
      };
      const completelyOff = (gridRect.right < 0 || gridRect.left > vpWidth ||
                               gridRect.bottom < 0 || gridRect.top > vpHeight);
      if (completelyOff) {
        grid.style.transition = "transform 0.5s ease-out";
        centerGrid();
      }
    }
    
    // Eventi mouse
    viewport.addEventListener("mousedown", (e) => {
      onDragStart(e.clientX, e.clientY);
    });
    window.addEventListener("mousemove", (e) => {
      onDragMove(e.clientX, e.clientY);
    });
    window.addEventListener("mouseup", onDragEnd);
    
    // Eventi touch
    viewport.addEventListener("touchstart", (e) => {
      if (e.touches.length === 1) {
        onDragStart(e.touches[0].clientX, e.touches[0].clientY);
      }
    }, {passive: false});
    viewport.addEventListener("touchmove", (e) => {
      if (e.touches.length === 1) {
        onDragMove(e.touches[0].clientX, e.touches[0].clientY);
        e.preventDefault();
      }
    }, {passive: false});
    viewport.addEventListener("touchend", onDragEnd);
    
    /**************************************************
     * ZOOM (rotella o trackpad)
     **************************************************/
    viewport.addEventListener("wheel", (e) => {
      e.preventDefault();
      const rect = viewport.getBoundingClientRect();
      // Punto del cursore relativo al viewport
      const cursor = {
        x: e.clientX - rect.left,
        y: e.clientY - rect.top
      };
      const oldZoom = zoomLevel;
      // Imposta il fattore di zoom: avanti se deltaY negativo, indietro se positivo
      const factor = e.deltaY < 0 ? 1.1 : 0.9;
      const newZoom = Math.min(Math.max(oldZoom * factor, 0.5), 5);
      
      // Calcola la nuova traslazione affinché il punto sotto il cursore resti fisso:
      translation.x = cursor.x - ((cursor.x - translation.x) * newZoom / oldZoom);
      translation.y = cursor.y - ((cursor.y - translation.y) * newZoom / oldZoom);
      
      zoomLevel = newZoom;
      updateTransform();
    }, {passive: false});
    
  </script>
</body>
</html>
