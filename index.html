<!DOCTYPE html>
<html lang="it">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Mosaic Navigabile - Natural Dimensions</title>
  <style>
    html, body {
      margin: 0;
      padding: 0;
      height: 100%;
      overflow: hidden;
      background: #222;
      user-select: none;
      touch-action: none;
    }
    /* Il viewport copre l'intero schermo e abilita la navigazione */
    #viewport {
      width: 100%;
      height: 100%;
      position: relative;
      overflow: hidden;
      cursor: grab;
    }
    /* Il container del mosaic: verrà posizionato e trasformato via JS */
    #grid {
      position: absolute;
      top: 0;
      left: 0;
      will-change: transform;
    }
    /* Le immagini dentro il mosaic:
       - vengono posizionate in modo assoluto secondo il layout calcolato,
       - non hanno margini/niente padding,
       - non sono draggabili (pointer-events: none). */
    #grid img {
      position: absolute;
      margin: 0;
      padding: 0;
      pointer-events: none;
    }
  </style>
</head>
<body>
  <div id="viewport">
    <div id="grid"></div>
  </div>
  <script>
    /**************************************************
     * Caricamento e layout del mosaic
     **************************************************/
    // Lista dei percorsi delle immagini (modifica se necessario)
    const imageFilenames = [
      "imgs/Unknown-1.jpeg",
      "imgs/Unknown.jpeg",
      "imgs/images-1.jpeg",
      "imgs/images.jpeg",
      "imgs/image5.jpg"
    ];
    // Per avere un mosaic denso ripetiamo la lista più volte
    const repeatFactor = 8; // Totale immagini = imageFilenames.length * repeatFactor
    const mosaicImageSources = [];
    for (let i = 0; i < repeatFactor; i++){
      imageFilenames.forEach(src => mosaicImageSources.push(src));
    }
    
    // Funzione che carica un'immagine e restituisce le sue dimensioni naturali
    function loadImage(src) {
      return new Promise((resolve, reject) => {
        const img = new Image();
        img.src = src;
        img.onload = () => resolve({
          src: src,
          width: img.naturalWidth,
          height: img.naturalHeight
        });
        img.onerror = () => reject(new Error("Failed to load: " + src));
      });
    }
    
    // Carica tutte le immagini
    Promise.all(mosaicImageSources.map(loadImage))
      .then(imagesData => {
        // Layout: disponi le immagini in righe senza spazi, senza forzare dimensioni.
        // Adottiamo un target per la larghezza di riga.
        const targetRowWidth = 1200;
        let rows = [];
        let currentRow = [];
        let currentRowWidth = 0;
        let currentRowHeight = 0;
        for (let data of imagesData) {
          // Se la riga non è vuota e aggiungendo l'immagine si supera il target,
          // inizia una nuova riga.
          if (currentRow.length > 0 && (currentRowWidth + data.width) > targetRowWidth) {
            rows.push({ images: currentRow, rowWidth: currentRowWidth, rowHeight: currentRowHeight });
            currentRow = [];
            currentRowWidth = 0;
            currentRowHeight = 0;
          }
          currentRow.push(data);
          currentRowWidth += data.width;
          currentRowHeight = Math.max(currentRowHeight, data.height);
        }
        if (currentRow.length > 0) {
          rows.push({ images: currentRow, rowWidth: currentRowWidth, rowHeight: currentRowHeight });
        }
        
        // Calcola le dimensioni complessive del mosaic.
        const mosaicWidth = Math.max(...rows.map(row => row.rowWidth));
        const mosaicHeight = rows.reduce((sum, row) => sum + row.rowHeight, 0);
        
        // Calcola le posizioni: per ogni riga, le immagini vengono posizionate
        // una accanto all'altra (x cumulativo) e y aumenta in base all'altezza della riga.
        let positionedImages = [];
        let yPos = 0;
        for (let row of rows) {
          let xPos = 0;
          for (let data of row.images) {
            positionedImages.push({
              src: data.src,
              x: xPos,
              y: yPos,
              width: data.width,
              height: data.height
            });
            xPos += data.width;
          }
          yPos += row.rowHeight;
        }
        
        // Imposta le dimensioni del container #grid in base al mosaic calcolato.
        const grid = document.getElementById("grid");
        grid.style.width = mosaicWidth + "px";
        grid.style.height = mosaicHeight + "px";
        
        // Aggiunge le immagini al container posizionandole assolutamente.
        positionedImages.forEach(data => {
          const imgEl = document.createElement("img");
          imgEl.src = data.src;
          // Lascia le dimensioni naturali, posiziona con left/top calcolati.
          imgEl.style.left = data.x + "px";
          imgEl.style.top = data.y + "px";
          grid.appendChild(imgEl);
        });
        
        // Inizializza pan e zoom partendo dalle dimensioni calcolate.
        initPanZoom(mosaicWidth, mosaicHeight);
      })
      .catch(err => {
        console.error(err);
      });
      
    /**************************************************
     * Pan & Zoom: funziona in modo standard come in Figma
     **************************************************/
    let zoomLevel = 1.0;
    let translation = { x: 0, y: 0 };
    const minZoom = 0.5;
    const maxZoom = 5;
    
    const viewport = document.getElementById("viewport");
    const grid = document.getElementById("grid");
    
    function updateTransform() {
      grid.style.transform = `translate(${translation.x}px, ${translation.y}px) scale(${zoomLevel})`;
    }
    
    // Centra il mosaic nel viewport in base alle dimensioni attuali e allo zoom
    function centerGrid(mosaicWidth, mosaicHeight) {
      const vpWidth = viewport.clientWidth;
      const vpHeight = viewport.clientHeight;
      translation.x = (vpWidth - mosaicWidth * zoomLevel) / 2;
      translation.y = (vpHeight - mosaicHeight * zoomLevel) / 2;
      updateTransform();
    }
    
    function initPanZoom(mosaicWidth, mosaicHeight) {
      // Centra inizialmente
      centerGrid(mosaicWidth, mosaicHeight);
      
      /***** PAN con mouse e touch *****/
      let isPanning = false;
      let panStart = { x: 0, y: 0 };
      let startTranslation = { x: 0, y: 0
