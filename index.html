<!DOCTYPE html>
<html lang="it">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Mosaic Navigabile con Zoom e Pan</title>
  <style>
    /* Rimuovo spazi e scroll, schermo intero */
    html, body {
      margin: 0;
      padding: 0;
      height: 100%;
      overflow: hidden;
      background: #222;
      user-select: none;
      -webkit-user-drag: none;
      touch-action: none;
    }
    /* Il viewport intero */
    #viewport {
      width: 100%;
      height: 100%;
      position: relative;
      overflow: hidden;
      cursor: grab;
    }
    /* Il container del mosaic: qui verranno aggiunte le immagini in posizione assoluta */
    #grid {
      position: absolute;
      left: 0;
      top: 0;
      will-change: transform;
    }
    /* Le immagini vengono lasciate nelle loro dimensioni reali, senza crop e senza rotazione */
    #grid img {
      position: absolute;
      display: block;
      user-select: none;
      pointer-events: none;
      margin: 0;
      padding: 0;
    }
  </style>
</head>
<body>
  <div id="viewport">
    <div id="grid"></div>
  </div>

  <script>
    /**************************************************
     * CONFIGURAZIONE E CREAZIONE DEL MOSAIC
     **************************************************/
    // Lista dei percorsi delle immagini (assicurati che siano nella cartella "imgs")
    const imageFilenames = [
      "imgs/Unknown-1.jpeg",
      "imgs/Unknown.jpeg",
      "imgs/images-1.jpeg",
      "imgs/images.jpeg",
      "imgs/image5.jpg"
    ];
    // Per simulare un gran numero di immagini, ripeto la lista
    const imagesList = [];
    const repeat = 20;  // ad esempio 20*la lunghezza dell'array
    for (let i = 0; i < repeat; i++) {
      imagesList.push(...imageFilenames);
    }

    // Assumiamo immagini di dimensione fissa (dummy: 500x500) â€“ modifica se necessario
    const baseWidth = 500;
    const baseHeight = 500;

    // Impostiamo la disposizione in griglia: scegliamo un numero di colonne
    const cols = 10;
    const rows = Math.ceil(imagesList.length / cols);

    // Recupera il container del mosaic
    const grid = document.getElementById("grid");
    // Dimensioni complessive (non scalate)
    grid.style.width  = (cols * baseWidth) + "px";
    grid.style.height = (rows * baseHeight) + "px";

    // Aggiunge ogni immagine in posizione calcolata (senza spazi e senza rotazione)
    imagesList.forEach((src, index) => {
      const img = document.createElement("img");
      img.src = src;
      img.style.width = baseWidth + "px";
      img.style.height = baseHeight + "px";
      // Calcola colonna e riga
      const col = index % cols;
      const row = Math.floor(index / cols);
      img.style.left = (col * baseWidth) + "px";
      img.style.top  = (row * baseHeight) + "px";
      grid.appendChild(img);
    });

    /**************************************************
     * IMPOSTAZIONE DI PAN E ZOOM
     **************************************************/
    const viewport = document.getElementById("viewport");

    // Stato della trasformazione
    let zoomLevel = 1.4;  // zoom iniziale (puoi modificarlo)
    let translation = { x: 0, y: 0 };

    // Variabili per il drag
    let isDragging = false;
    let dragStart = { x: 0, y: 0 };
    let startTranslation = { x: 0, y: 0 };

    // Aggiorna la trasformazione CSS del container grid
    function updateTransform() {
      grid.style.transform = `translate(${translation.x}px, ${translation.y}px) scale(${zoomLevel})`;
    }

    // Calcola la posizione centrale per il grid all'interno del viewport
    function centerGrid() {
      const vpWidth  = viewport.clientWidth;
      const vpHeight = viewport.clientHeight;
      // Dimensioni in scala attuale
      const currentWidth  = cols * baseWidth * zoomLevel;
      const currentHeight = rows * baseHeight * zoomLevel;
      translation.x = (vpWidth  - currentWidth)  / 2;
      translation.y = (vpHeight - currentHeight) / 2;
      updateTransform();
    }

    // Al caricamento e al resize centriamo
    centerGrid();
    window.addEventListener("resize", () => {
      // Disattiviamo le transizioni per il resize
      grid.style.transition = "none";
      centerGrid();
    });

    /**************************************************
     * GESTIONE DEL PANNING (MOUSE E TOUCH)
     **************************************************/
    // Mouse
    viewport.addEventListener("mousedown", (e) => {
      isDragging = true;
      dragStart = { x: e.clientX, y: e.clientY };
      startTranslation = { ...translation };
      grid.style.transition = "none";  // disattiva animazioni durante il drag
      viewport.style.cursor = "grabbing";
    });
    window.addEventListener("mousemove", (e) => {
      if (!isDragging) return;
      const dx = e.clientX - dragStart.x;
      const dy = e.clientY - dragStart.y;
      translation.x = startTranslation.x + dx;
      translation.y = startTranslation.y + dy;
      updateTransform();
    });
    window.addEventListener("mouseup", () => {
      if (!isDragging) return;
      isDragging = false;
      viewport.style.cursor = "grab";
      // Al termine del drag, torna al centro (animazione fluida)
      grid.style.transition = "transform 0.5s ease-out";
      centerGrid();
    });

    // Touch
    viewport.addEventListener("touchstart", (e) => {
      if (e.touches.length === 1) {
        isDragging = true;
        dragStart = { x: e.touches[0].clientX, y: e.touches[0].clientY };
        startTranslation = { ...translation };
      }
    }, { passive: false });
    viewport.addEventListener("touchmove", (e) => {
      if (!isDragging || e.touches.length !== 1) return;
      const dx = e.touches[0].clientX - dragStart.x;
      const dy = e.touches[0].clientY - dragStart.y;
      translation.x = startTranslation.x + dx;
      translation.y = startTranslation.y + dy;
      updateTransform();
      e.preventDefault();
    }, { passive: false });
    viewport.addEventListener("touchend", () => {
      if (!isDragging) return;
      isDragging = false;
      grid.style.transition = "transform 0.5s ease-out";
      centerGrid();
    });

    /**************************************************
     * GESTIONE DELLO ZOOM CON LA ROTELLA/ TRACKPAD
     **************************************************/
    viewport.addEventListener("wheel", (e) => {
      e.preventDefault();
      // Calcola il punto del cursore relativo al viewport
      const rect = viewport.getBoundingClientRect();
      const pointer = {
        x: e.clientX - rect.left,
        y: e.clientY - rect.top
      };
      // Imposta il fattore di zoom in/out
      const factor = e.deltaY < 0 ? 1.1 : 0.9;
      const oldZoom = zoomLevel;
      const newZoom = Math.min(Math.max(oldZoom * factor, 0.5), 5);
      // Ricalcola la traslazione per mantenere fisso il punto sotto il cursore:
      translation.x = pointer.x - ((pointer.x - translation.x) * newZoom / oldZoom);
      translation.y = pointer.y - ((pointer.y - translation.y) * newZoom / oldZoom);
      zoomLevel = newZoom;
      updateTransform();
    }, { passive: false });
  </script>
</body>
</html>
