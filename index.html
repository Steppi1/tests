<!DOCTYPE html>
<html lang="it">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Mappa Mosaic con Zoom e Pan Infinito</title>
  <style>
    html, body {
      margin: 0;
      padding: 0;
      height: 100%;
      overflow: hidden;
      background: #222;
      user-select: none;
      touch-action: none;
    }
    /* L’area intera, che fungerà da viewport interattivo */
    #viewport {
      width: 100%;
      height: 100%;
      background-color: #222;
      background-repeat: repeat;
      /* Il background verrà impostato via JS come immagine mosaic */
      cursor: grab;
    }
  </style>
</head>
<body>
  <div id="viewport"></div>
  <script>
    /*********************************************
     * Configurazione del mosaic
     *********************************************/
    // Lista di immagini – usa i percorsi relativi alla cartella imgs
    const imageFilenames = [
      "imgs/Unknown-1.jpeg",
      "imgs/Unknown.jpeg",
      "imgs/images-1.jpeg",
      "imgs/images.jpeg",
      "imgs/image5.jpg"
    ];

    // Ripeti la lista per avere un numero maggiore di immagini nel mosaic
    const mosaicRepeat = 20;  // il numero totale di immagini sarà: imageFilenames.length * mosaicRepeat
    const allImageSources = [];
    for (let i = 0; i < mosaicRepeat; i++) {
      allImageSources.push(...imageFilenames);
    }
    // Per il layout, definiamo quante colonne (in orizzontale) vogliamo
    const cols = 10;
    const rows = Math.ceil(allImageSources.length / cols);

    // Assumiamo che le immagini abbiano dimensioni “naturali”
    // (in questo esempio di dummy sono 500x500 – se le tue immagini hanno altre dimensioni, modifica di conseguenza)
    const baseWidth = 500;
    const baseHeight = 500;
    // Dimensione complessiva del mosaic (una singola “tile”)
    const mosaicWidth = cols * baseWidth;
    const mosaicHeight = rows * baseHeight;

    /*********************************************
     * Caricamento delle immagini e creazione del mosaic
     *********************************************/
    // Funzione helper per caricare una singola immagine
    function loadImage(src) {
      return new Promise((resolve, reject) => {
        const img = new Image();
        img.src = src;
        img.onload = () => resolve(img);
        img.onerror = () => reject(new Error("Impossibile caricare l'immagine: " + src));
      });
    }

    async function loadAllImages() {
      const promises = allImageSources.map(src => loadImage(src));
      return Promise.all(promises);
    }

    // Crea il mosaic disegnando su un canvas offscreen
    async function createMosaic() {
      const images = await loadAllImages();
      // Prepariamo un array di immagini per il mosaic: prendiamo i primi (cols * rows) elementi
      const totalCells = cols * rows;
      const mosaicImages = [];
      for (let i = 0; i < totalCells; i++) {
        // Se finiamo le immagini, ricorriamo con il modulo
        mosaicImages.push(images[i % images.length]);
      }
      // Mescola l'array in modo da avere una disposizione casuale
      for (let i = mosaicImages.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [mosaicImages[i], mosaicImages[j]] = [mosaicImages[j], mosaicImages[i]];
      }
      
      // Crea il canvas del mosaic
      const canvas = document.createElement("canvas");
      canvas.width = mosaicWidth;
      canvas.height = mosaicHeight;
      const ctx = canvas.getContext("2d");
      
      // Disegna le immagini in una griglia senza spazi (tutte attaccate)
      for (let i = 0; i < totalCells; i++) {
        const col = i % cols;
        const row = Math.floor(i / cols);
        const x = col * baseWidth;
        const y = row * baseHeight;
        // Disegna l'immagine senza modificare le proporzioni (nessun ritaglio, nessuna rotazione)
        ctx.drawImage(mosaicImages[i], x, y, baseWidth, baseHeight);
      }
      // Restituisce il dataURL del canvas
      return canvas.toDataURL();
    }

    /*********************************************
     * Stato interattivo e gestione dello zoom & pan
     *********************************************/
    // Variabili di stato
    let zoomLevel = 1.4;  // zoom iniziale (puoi modificarlo come preferisci)
    // L'offset rappresenta la posizione (in pixel) in cui parte il background.
    // Con background-repeat, modificando background-position otteniamo il panning infinito.
    let offset = { x: 0, y: 0 };

    // Riferimento al viewport
    const viewport = document.getElementById("viewport");

    // Imposta (o aggiorna) il background in funzione di zoom e offset
    function updateBackground() {
      // Il background-size definisce la dimensione (in pixel) di una "tile" del mosaic,
      // ottenuta moltiplicando le dimensioni originali per il livello di zoom
      const bgWidth = mosaicWidth * zoomLevel;
      const bgHeight = mosaicHeight * zoomLevel;
      viewport.style.backgroundSize = `${bgWidth}px ${bgHeight}px`;
      viewport.style.backgroundPosition = `${offset.x}px ${offset.y}px`;
    }

    // Calcola l'offset iniziale per centrare il mosaic nel viewport
    function centerBackground() {
      const vpWidth = window.innerWidth;
      const vpHeight = window.innerHeight;
      const bgWidth = mosaicWidth * zoomLevel;
      const bgHeight = mosaicHeight * zoomLevel;
      // Impostiamo l'offset in modo che il centro della tile coincida con il centro del viewport
      offset.x = vpWidth / 2 - bgWidth / 2;
      offset.y = vpHeight / 2 - bgHeight / 2;
      updateBackground();
    }

    /*********************************************
     * Panning: gestione del drag (mouse e touch)
     *********************************************/
    let isPanning = false;
    let startPoint = { x: 0, y: 0 };
    let startOffset = { x: 0, y: 0 };

    // Panning con mouse
    viewport.addEventListener("mousedown", (e) => {
      isPanning = true;
      startPoint = { x: e.clientX, y: e.clientY };
      startOffset = { ...offset };
      viewport.style.cursor = "grabbing";
    });
    window.addEventListener("mousemove", (e) => {
      if (!isPanning) return;
      const dx = e.clientX - startPoint.x;
      const dy = e.clientY - startPoint.y;
      offset.x = startOffset.x + dx;
      offset.y = startOffset.y + dy;
      updateBackground();
    });
    window.addEventListener("mouseup", () => {
      isPanning = false;
      viewport.style.cursor = "grab";
    });

    // Panning su dispositivi touch
    viewport.addEventListener("touchstart", (e) => {
      if (e.touches.length === 1) {
        isPanning = true;
        startPoint = { x: e.touches[0].clientX, y: e.touches[0].clientY };
        startOffset = { ...offset };
      }
    }, { passive: false });
    viewport.addEventListener("touchmove", (e) => {
      if (!isPanning || e.touches.length !== 1) return;
      const dx = e.touches[0].clientX - startPoint.x;
      const dy = e.touches[0].clientY - startPoint.y;
      offset.x = startOffset.x + dx;
      offset.y = startOffset.y + dy;
      updateBackground();
    }, { passive: false });
    viewport.addEventListener("touchend", () => {
      isPanning = false;
    });

    /*********************************************
     * Zoom: gestione della rotella (mouse/trackpad)
     *********************************************/
    viewport.addEventListener("wheel", (e) => {
      e.preventDefault();
      const rect = viewport.getBoundingClientRect();
      // Punto del cursore relativo al viewport
      const cursor = { 
        x: e.clientX - rect.left, 
        y: e.clientY - rect.top 
      };
      // Fattore di zoom: zoom in se deltaY negativo, zoom out se positivo
      const zoomFactor = e.deltaY < 0 ? 1.1 : 0.9;
      const newZoom = Math.min(Math.max(zoomLevel * zoomFactor, 0.5), 5);
      
      // Dimensioni correnti e nuove del background
      const oldBgWidth = mosaicWidth * zoomLevel;
      const oldBgHeight = mosaicHeight * zoomLevel;
      const newBgWidth = mosaicWidth * newZoom;
      const newBgHeight = mosaicHeight * newZoom;
      
      // Calcola la posizione relativa del cursore nel background attuale
      const relX = (cursor.x - offset.x) / oldBgWidth;
      const relY = (cursor.y - offset.y) / oldBgHeight;
      
      // Aggiorna offset in modo che il punto sotto il cursore rimanga fisso
      offset.x = cursor.x - relX * newBgWidth;
      offset.y = cursor.y - relY * newBgHeight;
      
      zoomLevel = newZoom;
      updateBackground();
    }, { passive: false });

    /*********************************************
     * Gestione del resize: ricentra il mosaic
     *********************************************/
    window.addEventListener("resize", centerBackground);

    /*********************************************
     * Avvio: crea il mosaic e imposta lo sfondo
     *********************************************/
    createMosaic().then((dataURL) => {
      viewport.style.backgroundImage = `url(${dataURL})`;
      centerBackground();
    }).catch((err) => {
      console.error(err);
    });
  </script>
</body>
</html>
